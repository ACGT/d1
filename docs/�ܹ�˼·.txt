1：数据库用mysql（廉价、同步、监控、开源支持）

2：数据库先垂直分割再水平分割
如用户、用户积分、积分日志、用户收货地址等用户相关数据放一台mysql（用户可以按照id再拆分成N个表）。
商品、库存、分类、目录等商品数据放一个mysql。
交易、购物车等相关交易数据放一个mysql。（交易也可以按照userId散列成N个表）
其他如CMS、新闻、评论、管理员、用户权限等等放一个mysql。
（具体如何拆分要根据业务逻辑和科学的压力计算来确定）

3：数据库采用【双master+多slave、读写分离】的构架
（读写分离不是完完全全的读写分离，有的数据对时效性要求很高，不能从slave中读取，策略如下）
每组A、B两台master数据库互相备份，B留着备用，万一A挂了，监控系统（shell、heartbeat、mmm、程序监控）自动切换到B，等A恢复了再切换到A，
A和B还可以有slave C、slave D等slave服务器。
（监测项：ping不通/端口不通/连接超时/执行sql超时/执行sql连续异常/连接数过多/load average太大/Lock时间过长/...）
其中create、insert、update全都在A上进行，另外，像select...limit N,M (N<=100 && M<=100)，select...where id = Y（时效性要求比较高、对性能影响不大）的查询也在A上执行。
其他如select count(*)...、select sum(*)...、select...limit N,M (N>100 || M>100) 等查询全部发到slave上。
多slave上的查询采用LVS做负载均衡或者用变形虫（amoeba）统一管理。
由于对master的稳定性要求特别高，所以不允许有大的查询在master上进行，如果有超过5秒的查询锁（肯定不应该出现在master上），可以利用监控shell将该查询锁杀死，
不能让一个错误耽误其他用户操作，杀死后会留日志、发邮件和短信，给程序员查找问题提供依据。
对部分操作特别频繁的表（临时数据）可用内存表或延时更新策略。
ERP报表和财务数据等再单独同步到M台slave服务器中（mysql或oracle），ERP所有修改仍须在master A上进行，所有slave都不能有增删改的操作。
对于数据量更新特别快的需求（如每秒1w次insert/update/create），只能采用延时写，可以再建立一个mysql或Nosql(mongodb/cassandra)，用内存表实现管道处理。
（以上办法在同步、异步、高性能、稳定性、一致性、时效性上取了一个折中，可以实现且基本能满足需求）

4：缓存方案
对象全部采用memcached分布式缓存（memcached已经实现分布式和Consistent Hashing散列策略），所有对象的缓存和master数据必须完全同步。
从master获取的列表（如select ... limit 0,5，时效性要求很高）也采用memcached分布式存储，通过一定的策略对缓存进行维护，保证缓存和数据库的一致性。
从slave上获取的列表（如select count* ...时效性要求不高）可以根据其时效性要求放入memcached中存入一定时间（比如10秒、30秒），这样也可以很大程度的减轻slave压力。
★所有对象都加上版本号（可通过应用服务器可动态修改），这样可以单独让一个对象（一个表）的缓存全部失效，不至于某个表增加一个字段时要重启所有memcached服务器。

5：事务处理
事务和缓存不冲突，执行事务过程中直接清除缓存就行，就算万一事务回滚，也只是多清除了一点缓存而已，缓存和数据库还是保持一致的。
对于分布式事务，首先建议解决办法是有关联事务的表放在一个mysql中，如果没法这么拆，则采用分批事务（一个大事务包含N个小事务），同时commit、同时rollback。
★建议大规模的计算放在应用服务器上，而不是直接用嵌套的select和联查在数据库上实现。

6：分布式协同服务（分布式锁）
对于安全级别要求特别高的操作，比如冻结库存、修改商品等操作采用分布式锁zookeeper来实现分布式同步。

7：应用服务器分布式
由于全采用了memcached做集中式缓存，所以应用服务器之间没有任何通讯，这样可以任意扩展应用服务器。
分布式session也用memcached实现。
F5、LVS、nginx做负载均衡，视投入情况和需求而定。

8：全文检索
lucene+tmpfs+分布式实现，LVS或nginx做负载均衡。
采用短语搜索策略，不用分词，用户自己通过空格分词，建议默认只对商品标题搜索，搜内容的话相关性太差。
根据数据刷新频率采用实时刷新索引或定时刷新。
全文检索还可以设置一定时间的缓存，即使缓存10-30秒也会大大减轻压力。
排序策略：如果数据量量小（小于1000条）可以全部取出来再排序，如果数据量大可以先筛选（比如最新发布的1000个）然后排序。

9：图片服务器
采用分布式文件系统或者散列存储（按功能散列、按日期散列）的办法，lighttpd+mod_mem_cache是个比较好的解决办法（单服务器能撑500M/s以上）。
静态或很少做修改的视频或者大图片，访问量特大的可用CND加速。
F5或LVS做负载均衡。

10：页面静态化
对极少修改的页面进行静态化。
对部分页面做半静态化（一定时间内不更新）。
其他采用动态页面+缓存的方式。
动态页面URL静态化采用urlrewrite。


需要的服务器：java应用5台，memcached 5台，mysql 16台（4组，每组2个master+2个slave），Oracle 2台（汇总mysql数据，供财务报表计算和查询），
全文检索3台，图片3台，分布式锁3台，变形虫5台。共计40台，用廉价的服务器就行（视情况增加内存和磁盘空间），撑1500万PV问题不大，若要撑3000万pv，
估计增加5个应用服务器、5个memcached服务器就差不多了，其他的服务器不用增加多少。


